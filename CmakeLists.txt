cmake_minimum_required(VERSION 3.15.6)

set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)

project(helia_aot_fvp_tests C)

# ---- User-configurable cache vars (same names/behavior as UnitTest CMake) ----
set(CMSIS_PATH "downloads/CMSIS_5" CACHE PATH "Path to CMSIS (CMSIS_5 checkout).")
set(CMSIS_OPTIMIZATION_LEVEL "-Ofast" CACHE STRING "Optimization flags for CMSIS-NN build/tests")

set(FVP_CORSTONE_300_PATH "${CMAKE_CURRENT_SOURCE_DIR}/Corstone-300" CACHE PATH
    "Dependencies for using FVP based on Arm Corstone-300 software.")

set(CMAKE_EXECUTABLE_SUFFIX ".elf")


# Optional: override where ns-cmsis-nn root lives (default is the folder we have)
set(CMSIS_NN_ROOT
    "${CMAKE_CURRENT_SOURCE_DIR}/modules/ns-cmsis-nn"
    CACHE PATH "Path to ns-cmsis-nn repository root")

# Coverage option
option(ENABLE_COVERAGE "Enable code coverage" OFF)

    if (CMSIS_PATH STREQUAL "downloads/CMSIS_5")
    message(FATAL_ERROR "CMSIS_PATH not set. Provide -DCMSIS_PATH=<.../CMSIS_5>")
  endif()

# Build .elf images (FVP expects bare-metal ELF)
set(CMAKE_EXECUTABLE_SUFFIX ".elf")

# ---- Warnings & global compile options (mirrors UnitTest defaults) ----
add_compile_options(
  -fomit-frame-pointer
  -Werror
  -Wimplicit-function-declaration
  -Wunused-variable
  -Wunused-function
  -Wno-redundant-decls
  -Wvla
)
add_compile_options(${CMSIS_OPTIMIZATION_LEVEL})


# ---- Global linker options for bare-metal ARM GCC ----
if (CMAKE_C_COMPILER_ID STREQUAL "GNU")
  add_link_options("--specs=nosys.specs")
  add_link_options(
    -mcpu=${CMAKE_SYSTEM_PROCESSOR}
    -mthumb
  )
  
  # Set float ABI for linker based on CPU architecture
  if (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m3")
    add_link_options(-mfloat-abi=soft)
  elseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m4")
    add_link_options(-mfloat-abi=hard -mfpu=fpv4-sp-d16)
  elseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m7")
    add_link_options(-mfloat-abi=hard -mfpu=fpv5-d16)
  elseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m33" OR ${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m55")
    add_link_options(-mfloat-abi=hard -mfpu=fpv5-sp-d16)
  else()
    add_link_options(-mfloat-abi=soft)
  endif()
endif()

# ---- Global compile options for ARM Cortex-M processors ----
if (CMAKE_C_COMPILER_ID STREQUAL "GNU")
  add_compile_options(
    -mcpu=${CMAKE_SYSTEM_PROCESSOR}
    -mthumb
  )
  
  # Set float ABI based on CPU architecture
  if (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m3")
    # Cortex-M3 has no FPU
    add_compile_options(-mfloat-abi=soft)
  elseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m4")
    # Cortex-M4 has single precision FPU
    add_compile_options(-mfloat-abi=hard -mfpu=fpv4-sp-d16)
  elseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m7")
    # Cortex-M7 has double precision FPU
    add_compile_options(-mfloat-abi=hard -mfpu=fpv5-d16)
  elseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m33" OR ${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m55")
    # Cortex-M33/M55 have single precision FPU
    add_compile_options(-mfloat-abi=hard -mfpu=fpv5-sp-d16)
  else()
    # Default to soft float for unknown architectures
    add_compile_options(-mfloat-abi=soft)
  endif()
endif()

# ---- Bring in cmsis-nn as a subproject (same as UnitTest does) ----
# The UnitTest CMake uses: add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/../.. cmsis-nn)
# Here we expect CMSIS_NN_ROOT to be the ns-cmsis-nn repo root.
if (EXISTS "${CMSIS_NN_ROOT}/CMakeLists.txt")
  add_subdirectory("${CMSIS_NN_ROOT}" cmsis-nn)
  
else()
  message(FATAL_ERROR "cmsis-nn CMakeLists.txt not found at: ${CMSIS_NN_ROOT}")
endif()

# ---- Unity (lightweight) via FetchContent (we only need unity.c + headers) ----
include(FetchContent)
FetchContent_Declare(unity
  GIT_REPOSITORY https://github.com/ThrowTheSwitch/Unity.git
  GIT_TAG        v2.6.0
  GIT_SHALLOW    TRUE
)
FetchContent_MakeAvailable(unity)

# Unity upstream doesn't ship a CMake target by default; create a tiny static lib.
add_library(unity_fetch STATIC ${unity_SOURCE_DIR}/src/unity.c)
target_include_directories(unity_fetch PUBLIC ${unity_SOURCE_DIR}/src)

# ---- FVP retarget + startup (copied from UnitTest logic) ----
add_library(retarget STATIC
  ${FVP_CORSTONE_300_PATH}/retarget.c
  ${FVP_CORSTONE_300_PATH}/uart.c
)
target_compile_definitions(retarget PUBLIC USING_FVP_CORSTONE_300)

# Map CMAKE_SYSTEM_PROCESSOR (from toolchain) to ARMCM* device name used by CMSIS-5 startup
# Expect CMAKE_SYSTEM_PROCESSOR like "cortex-m55", "cortex-m33", etc.
if (NOT CMAKE_SYSTEM_PROCESSOR)
  message(FATAL_ERROR "CMAKE_SYSTEM_PROCESSOR not set (ensure your toolchain file sets it, e.g. cortex-m55)")
endif()
string(REGEX REPLACE "^cortex-m([0-9]+)$" "ARMCM\\1" ARM_CPU ${CMAKE_SYSTEM_PROCESSOR})

if (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m33")
  set(ARM_FEATURES "_DSP_FP")
elseif(${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m4")
  set(ARM_FEATURES "_FP")
elseif(${CMAKE_SYSTEM_PROCESSOR} STREQUAL "cortex-m7")
  set(ARM_FEATURES "_DP")
else()
  set(ARM_FEATURES "")
endif()

add_library(cmsis_startup STATIC)
target_sources(cmsis_startup PRIVATE
  ${CMSIS_PATH}/Device/ARM/${ARM_CPU}/Source/startup_${ARM_CPU}.c
  ${CMSIS_PATH}/Device/ARM/${ARM_CPU}/Source/system_${ARM_CPU}.c
)
target_include_directories(cmsis_startup PUBLIC
  ${CMSIS_PATH}/Device/ARM/${ARM_CPU}/Include
  ${CMSIS_PATH}/CMSIS/Core/Include
)
# Processor-specific flags are now applied globally
# Inject pre-include to pick correct device header (matches UnitTest)
target_compile_options(cmsis_startup INTERFACE -include${ARM_CPU}${ARM_FEATURES}.h)
target_compile_definitions(cmsis_startup PRIVATE ${ARM_CPU}${ARM_FEATURES})

# Linker script selection (GNU vs ArmClang)
if (CMAKE_C_COMPILER_ID STREQUAL "ARMClang" OR CMAKE_CXX_COMPILER_ID STREQUAL "ARMClang")
  set(LINK_FILE "${FVP_CORSTONE_300_PATH}/linker.scatter")
  set(LINK_FILE_OPTION "--scatter")
  set(LINK_ENTRY_OPTION "--entry")
  set(LINK_ENTRY "Reset_Handler")
elseif (CMAKE_C_COMPILER_ID STREQUAL "GNU" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
  set(LINK_FILE "${FVP_CORSTONE_300_PATH}/linker.ld")
  set(LINK_FILE_OPTION "-T")
  set(LINK_ENTRY_OPTION "")
  set(LINK_ENTRY "")
else()
  message(FATAL_ERROR "Unsupported compiler for FVP linking: ${CMAKE_C_COMPILER_ID}")
endif()

# ---- Helper: normalize a path into a valid target name ----
function(_normalize_target_name out_var in_path)
  string(REGEX REPLACE "^GeneratedTests/([^/]+).*" "\\1" _tgt "${in_path}")
  set(${out_var} "${_tgt}" PARENT_SCOPE)
endfunction()

# ---- Discover generated test runners under GeneratedTests/**/test_runner.c ----
file(GLOB_RECURSE GENERATED_TEST_RUNNERS
  RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}"
  "GeneratedTests/*/*/*/test_runner.c"
  "GeneratedTests/*/*/test_runner.c"
)

if (GENERATED_TEST_RUNNERS)
  message(STATUS "Discovered ${GENERATED_TEST_RUNNERS}")
else()
  message(WARNING "No GeneratedTests/*/*/*/test_runner.c found. Did you run your generator?")
endif()

# Collect all test targets in a global list
set(GENERATED_TEST_TARGETS "")

foreach(TR_REL ${GENERATED_TEST_RUNNERS})
  get_filename_component(TEST_DIR_REL "${TR_REL}" DIRECTORY)
  get_filename_component(TEST_DIR_ABS "${TEST_DIR_REL}" ABSOLUTE)

  # Create a target name from the relative directory path
  _normalize_target_name(TGT_NAME "${TEST_DIR_REL}")

  # Sources: test_runner.c + module sources under src/
  file(GLOB MODULE_SRCS "${TEST_DIR_ABS}/src/*.c")
  set(SRCS "${TEST_DIR_ABS}/test_runner.c" ${MODULE_SRCS})

  if (SRCS STREQUAL "")
    message(WARNING "No sources found for ${TEST_DIR_REL}; skipping.")
    continue()
  endif()

  add_executable(${TGT_NAME} ${SRCS})

  # GNU newlib minimal syscalls (match UnitTest behavior)
  if (CMAKE_C_COMPILER_ID STREQUAL "GNU")
    target_link_options(${TGT_NAME} PRIVATE "--specs=nosys.specs")
  endif()

  # Processor-specific flags are now applied globally

  # Include dirs: generated public API and your local cmsis.h
  # NeuralSPOT includes - add all neuralspot module includes-api directories
  file(GLOB NEURALSPOT_INCLUDE_DIRS 
    "${CMAKE_CURRENT_SOURCE_DIR}/modules/neuralSPOT/neuralspot/ns-*/includes-api"
  )
  
  target_include_directories(${TGT_NAME} PRIVATE
    "${TEST_DIR_ABS}/includes-api"
    "${CMAKE_CURRENT_SOURCE_DIR}/src"   # for src/cmsis.h (PMU/DWT helpers)
    ${NEURALSPOT_INCLUDE_DIRS}  # All neuralSPOT module includes
    "${CMAKE_CURRENT_SOURCE_DIR}/modules/neuralSPOT/extern/AmbiqSuite/R5.1.0_rc27/utils"  # for am_util.h
    "${CMAKE_CURRENT_SOURCE_DIR}/modules/neuralSPOT/extern/AmbiqSuite/R5.1.0_rc27/boards/apollo510_evb/bsp"  # for am_bsp.h (FVP uses apollo510)
    "${CMAKE_CURRENT_SOURCE_DIR}/modules/neuralSPOT/extern/AmbiqSuite/R5.1.0_rc27/CMSIS/ARM/Include"  # CMSIS core headers
    "${CMAKE_CURRENT_SOURCE_DIR}/modules/neuralSPOT/extern/AmbiqSuite/R5.1.0_rc27/CMSIS/AmbiqMicro/Include"  # Ambiq CMSIS device headers
    "${CMAKE_CURRENT_SOURCE_DIR}/modules/neuralSPOT/extern/CMSIS/CMSIS-DSP-1.16.2/Include"  # for arm_math.h
  )

  # All tests use FVP defines
  target_compile_definitions(${TGT_NAME} PUBLIC USING_FVP_CORSTONE_300)
  
  # Suppress warnings for generated test files
  target_compile_options(${TGT_NAME} PRIVATE 
    -Wno-switch-default
    -Wno-unused-parameter
    -Wno-cast-align
  )

  # Link deps: unity + cmsis-nn + startup + retarget
  target_link_libraries(${TGT_NAME} PRIVATE unity_fetch cmsis-nn retarget cmsis_startup)

  # Apply FVP linker script + optional entry, and make CMake rebuild on script change
  target_link_options(${TGT_NAME} PRIVATE ${LINK_FILE_OPTION} ${LINK_FILE} ${LINK_ENTRY_OPTION} ${LINK_ENTRY})
  set_target_properties(${TGT_NAME} PROPERTIES LINK_DEPENDS ${LINK_FILE})

  # Record target
  list(APPEND GENERATED_TEST_TARGETS ${TGT_NAME})
endforeach()

# Aggregate target to build all generated tests in one go
if (GENERATED_TEST_TARGETS)
  add_custom_target(generated_tests ALL DEPENDS ${GENERATED_TEST_TARGETS})
endif()

# ---- Create tests directory and move ELF files there ----
# Create tests directory
file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/tests")

# Custom target to move ELF files to tests directory after building
if (GENERATED_TEST_TARGETS)
  add_custom_target(organize_tests ALL)
  
  foreach(TGT_NAME ${GENERATED_TEST_TARGETS})
    # Get the output file path
    get_target_property(OUTPUT_NAME ${TGT_NAME} OUTPUT_NAME)
    if (NOT OUTPUT_NAME)
      set(OUTPUT_NAME ${TGT_NAME})
    endif()
    
    # Add .elf extension if not present
    if (NOT OUTPUT_NAME MATCHES "\\.elf$")
      set(OUTPUT_NAME "${OUTPUT_NAME}.elf")
    endif()
    
    # Define source and destination paths
    set(ELF_SOURCE "${CMAKE_BINARY_DIR}/${OUTPUT_NAME}")
    set(ELF_DESTINATION "${CMAKE_BINARY_DIR}/tests/${OUTPUT_NAME}")
    
    # Add custom command to move the ELF file
    # Write executables directly into the tests directory instead of copying
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/tests")
    set_target_properties(${TGT_NAME}
      PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/tests"
    )
    
    # Make organize_tests depend on each test target
    add_dependencies(organize_tests ${TGT_NAME})
  endforeach()
endif()

# ---- Nice-to-have: print a short summary at configure time ----
message(STATUS "Summary:")
message(STATUS "  CMSIS_PATH             : ${CMSIS_PATH}")
message(STATUS "  CMSIS_NN_ROOT          : ${CMSIS_NN_ROOT}")
message(STATUS "  FVP_CORSTONE_300_PATH  : ${FVP_CORSTONE_300_PATH}")
message(STATUS "  TARGET CPU (toolchain) : ${CMAKE_SYSTEM_PROCESSOR}")
message(STATUS "  Generated test targets : ${GENERATED_TEST_TARGETS}")
message(STATUS "  Tests directory        : ${CMAKE_BINARY_DIR}/tests")
